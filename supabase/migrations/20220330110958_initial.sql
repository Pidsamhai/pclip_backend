-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.room
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    name character varying COLLATE pg_catalog."default" NOT NULL,
    iv character varying(16) COLLATE pg_catalog."default" NOT NULL DEFAULT substr(md5((random())::text), 0, 17),
    owner uuid NOT NULL DEFAULT auth.uid(),
    CONSTRAINT room_pkey PRIMARY KEY (id),
    CONSTRAINT room_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.room_member
(
    device_name character varying COLLATE pg_catalog."default" NOT NULL,
    room_id uuid NOT NULL,
    member_id uuid NOT NULL,
    create_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT room_member_pkey PRIMARY KEY (room_id, member_id),
    CONSTRAINT room_member_member_id_fkey FOREIGN KEY (member_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT room_member_room_id_fkey FOREIGN KEY (room_id)
        REFERENCES public.room (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.room_message
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    message text COLLATE pg_catalog."default" NOT NULL,
    expired timestamp without time zone,
    sender uuid DEFAULT auth.uid(),
    room_id uuid NOT NULL,
    create_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT room_message_pkey PRIMARY KEY (id),
    CONSTRAINT room_message_room_id_fkey FOREIGN KEY (room_id)
        REFERENCES public.room (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT room_message_sender_fkey FOREIGN KEY (sender)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.room_member_invite
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    room_secret_encrypt text COLLATE pg_catalog."default" NOT NULL,
    invite_id character varying(6) COLLATE pg_catalog."default" NOT NULL,
    invite_secret_hash text COLLATE pg_catalog."default" NOT NULL,
    expired timestamp with time zone NOT NULL DEFAULT (now() + '00:05:00'::interval),
    room_id uuid NOT NULL,
    CONSTRAINT room_member_invite_pkey PRIMARY KEY (id),
    CONSTRAINT room_member_invite_room_id_fkey FOREIGN KEY (room_id)
        REFERENCES public.room (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;


CREATE OR REPLACE FUNCTION public.get_room_auth_user(
	)
    RETURNS SETOF uuid 
    LANGUAGE 'sql'
    COST 100
    STABLE SECURITY DEFINER PARALLEL UNSAFE
    ROWS 1000

    SET search_path=public
AS $BODY$
 
    SELECT room_id FROM room_member
    WHERE member_id = auth.uid () 
  
$BODY$;

ALTER FUNCTION public.get_room_auth_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_room_auth_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_room_auth_user() TO anon;

GRANT EXECUTE ON FUNCTION public.get_room_auth_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_room_auth_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.get_room_auth_user() TO service_role;

CREATE OR REPLACE FUNCTION public.is_owner(
	room_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    STABLE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$
    SELECT TRUE FROM room
    WHERE owner = auth.uid () 
  
$BODY$;

ALTER FUNCTION public.is_owner(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_owner(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_owner(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_owner(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_owner(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_owner(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.is_member(
	room_id uuid)
    RETURNS boolean
    LANGUAGE 'sql'
    COST 100
    STABLE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$
    SELECT TRUE FROM room_member
    WHERE member_id = auth.uid ()
    AND room_id = room_id 
  
$BODY$;

ALTER FUNCTION public.is_member(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_member(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_member(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.is_member(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_member(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.is_member(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.handle_member()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
BEGIN
    INSERT INTO public.room_member (room_id, member_id, device_name)
    VALUES (new.id, new.owner, 'owner');
  RETURN new;
END;
$BODY$;

ALTER FUNCTION public.handle_member()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_member() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_member() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_member() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_member() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_member() TO service_role;

ALTER TABLE IF EXISTS public.room_member
    OWNER to postgres;

ALTER TABLE IF EXISTS public.room_member
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.room_member TO anon;

GRANT ALL ON TABLE public.room_member TO authenticated;

GRANT ALL ON TABLE public.room_member TO postgres;

GRANT ALL ON TABLE public.room_member TO service_role;
CREATE POLICY "Allow member can read members"
    ON public.room_member
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (is_member(room_id));
CREATE POLICY "Allow member or owner can delete member"
    ON public.room_member
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (((auth.uid() = member_id) OR is_owner(room_id)));

ALTER TABLE IF EXISTS public.room
    OWNER to postgres;

ALTER TABLE IF EXISTS public.room
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.room TO anon;

GRANT ALL ON TABLE public.room TO authenticated;

GRANT ALL ON TABLE public.room TO postgres;

GRANT ALL ON TABLE public.room TO service_role;

GRANT UPDATE(name) ON public.room TO authenticated;
CREATE POLICY "Allow member can update room"
    ON public.room
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() = owner));
CREATE POLICY "Allow member read room"
    ON public.room
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((id IN ( SELECT get_room_auth_user() AS get_room_auth_user)));
CREATE POLICY "Allow user can create room"
    ON public.room
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (("right"(auth.email(), 25) <> '@anon-users.pidsamhai.com'::text));

CREATE TRIGGER on_room_created
    AFTER INSERT
    ON public.room
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_member();

ALTER TABLE IF EXISTS public.room_member_invite
    OWNER to postgres;

ALTER TABLE IF EXISTS public.room_member_invite
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.room_member_invite TO anon;

GRANT ALL ON TABLE public.room_member_invite TO authenticated;

GRANT ALL ON TABLE public.room_member_invite TO postgres;

GRANT ALL ON TABLE public.room_member_invite TO service_role;

ALTER TABLE IF EXISTS public.room_message
    OWNER to postgres;

ALTER TABLE IF EXISTS public.room_message
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.room_message TO anon;

GRANT ALL ON TABLE public.room_message TO authenticated;

GRANT ALL ON TABLE public.room_message TO postgres;

GRANT ALL ON TABLE public.room_message TO service_role;
CREATE POLICY "Allow member can read message"
    ON public.room_message
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((is_member(room_id) AND ((expired IS NULL) OR (expired >= now()))));
CREATE POLICY "Allow member send message"
    ON public.room_message
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (is_member(room_id));
CREATE POLICY "Allow sender can delete message"
    ON public.room_message
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = sender));
